from sympy.matrices.matrices import MatrixBase
from sympy.utilities.iterables import flatten
from sympy.core import Basic
from sympy.matrices import zeros, Matrix, eye, ones
from sympy.core.sympify import _sympify
from functools import wraps


def list2matrix(func):
    """Decorator for functions that take
    vectors as args and need to be in the Matrix
    object.  Allows for simple conversion while not
    populating each function with explicit conversion.
    Really only effective and tested for Standard_Cartan methods."""
    def checkmat(x):
        if isinstance(x, list) or isinstance(x, tuple):
            x = Matrix(x)
            if x.shape[-1] == 1:
                x = x.T
        return x
    @wraps(func)
    def wrapper(*args, **kwargs):
        wargs = []
        for arg in args:
            arg = checkmat(arg)
            wargs.append(arg)
        wkwargs = {}
        for k,v in kwargs.items():
            v = checkmat(v)
            kwargs[k]=v
        return func(*wargs, **wkwargs)
    return wrapper

from .orbit_backend import orbit, root_system

class Standard_Cartan(Basic):
    """
    Semi-Concrete base class for Cartan types such as A4, etc. In this module we make
    certain choices about how to represent the algebra.  This class is never meant to be
    called directly. It is exported as `CartanType` and should be called that way.

    Most of the methods are implemented from Mathematica library LieART and the
    text by Howard Georgi. Sources are listed below and additional sources, if
    included, are on each method.

    Examples
    ========
    >>> from sympy.liealgebras import CartanType
    >>> CartanType("G2")
    TypeG('G', 2)

    Sources
    =======
    - https://inspirehep.net/literature/181168
    - https://www.researchgate.net/publication/252487471_Group_Theory_A_Physicist's_Survey
    - https://arxiv.org/pdf/1206.6379.pdf
    - http://sporadic.stanford.edu/Math210C/lecture14.pdf
    """

    def __new__(cls, series, n):
        n= _sympify(n)
        return super().__new__(cls, series, n)

    @property
    def rank(self):
        """
        Returns the rank of the Lie algebra
        """
        return self.args[1]

    @property
    def series(self):
        """
        Returns the type of the Lie algebra
        """
        return self.args[0]

    def cartan_matrix(self):
        r"""
        Returns the Cartan Matrix for the algebra. For a
        given simple Lie algebra the elements $a_{ij}$ can be
        generated by

        .. math::
            a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle

        where $a_i$ is the i'th simple root and $\langle,\rangle$ is the scalar product.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Cartan_matrix
        - https://mathworld.wolfram.com/CartanMatrix.html

        """
        if hasattr(self, "_cartan_matrix"):
            return self._cartan_matrix
        r = self.rank
        cartan_matrix = zeros(r,r)
        for i, sr_i in enumerate(self.simple_roots()):
            for j, sr_j in enumerate(self.simple_roots()):
                cartan_matrix[j,i] = 2 * sr_i.dot(sr_j) / sr_i.dot(sr_i)
        self._cartan_matrix = cartan_matrix
        return self._cartan_matrix

    def cocartan_matrix(self):
        r"""
        Returns the Cocartan matrix. The Cocartan matrix
        row elements, $c_i$, are built from covectors of simple roots, $\alpha_i$.

        .. math::
            c_i = 2 \alpha_i / \langle \alpha_i, \alpha_i \rangle

        This relationship is helpful in defining the orthogonal base where
        multiplying by some weight, $w_j$, yields the unit matrix.

        .. math::
            \langle c_i, w_j \rangle = \delta_{ij}

        """
        if hasattr(self, "_cocartan_matrix"):
            return self._cocartan_matrix
        self._cocartan_matrix = Matrix([
                2 * x / x.dot(x) for x in self.simple_roots()])
        return self._cocartan_matrix

    def omega_matrix(self):
        """
        Returns the omega matrix whose rows are built from
        the fundamental weights of the algebra in the orthogonal
        basis.
        """
        if hasattr(self, "_omega_matrix"):
            return self._omega_matrix
        self._omega_matrix = self.cocartan_matrix().pinv().T
        return self._omega_matrix

    def simple_root(self, i):
        """
        Returns the i'th simple root in the orthogonal basis.
        """
        raise NotImplementedError("Do not call this method directly from the base class.")

    # explicit return annotation to help pylance users
    def simple_roots(self) -> list:
        """
        Returns the simple roots of the algebra in the orthogonal basis.
        """
        return [Matrix(self.simple_root(i+1)) for i in range(self.rank)]

    def fundamental_weight(self, i):
        r"""
        Returns the i'th fundamental weight of the algebra in the
        orthogonal basis.

        Note: To match consistency with simple roots, i starts at 1.

        Explanation
        ===========
        The weights of an algebra, lambda, can be
        written as a linear combination of the simple roots, $\alpha_i$.
        The following theorem,

        .. math::
            a_i = 2\langle\lambda, \alpha_i \rangle / \langle\alpha_i, \alpha_i \rangle


        where $a_i$ are the Dynkin labels.  The fundamental weights
        of the algebra are the weights, lambda, with the smallest $a_i >= 0$.
        Note that if $\lambda_i==\alpha_i$, then the Dynkin labels become
        the elements of the Cartan matrix.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Weight_(representation_theory)
        - http://www.math.columbia.edu/~woit/notes11.pdf
        """
        i = i - 1
        return self.omega_matrix().row(i)

    def fundamental_weights(self):
        """
        Returns a list of the fundamental weights in the orthogonal basis
        """
        return [self.fundamental_weight(i) for i in range(self.omega_matrix().rows)]

    def rootsystem(self, **kwargs):
        """Returns the root system of the group ordered from
        highest root to lowest in the orthogonal basis. The roots are found by reflecting
        each simple root about its hyperplane, repeating this procedure
        on each subsequent root generated until no more are found.
        The roots are then weighed and sorted according to weight.

        Note: This is a costly calculation for groups with
        rank > 6, most notably E7 and E8, so numpy backend is employed.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> CartanType("A2").rootsystem()
        [Matrix([[1, 0, -1]]),
        Matrix([[0, 1, -1]]),
        Matrix([[1, -1, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[-1, 1, 0]]),
        Matrix([[0, -1, 1]]),
        Matrix([[-1, 0, 1]])]
        """
        return root_system(self, **kwargs)

    def roots(self) -> Matrix:
        """Returns the number of total roots in the algebra"""
        raise NotImplementedError("Do not call this method directly from the base class.")


    def root_level(self, root, basis='orthogonal'):
        """Returns the root level of the root. The root level is calculated
        by rotating by the omega matrix and then summing the rotated vector.
        The basis argument flags which basis the incoming root or weight is in.

        Args:
            root (Matrix): A Matrix of shape (1, rank)
            basis (str): Which basis incoming root or weight is in.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> g2 = CartanType("G2")
        >>> rs = g2.rootsystem()
        >>> g2.root_level(rs[0])
        5
        """
        if not hasattr(self, "_cached_r"):
            inverse_cartan = self.cartan_matrix().pinv()
            self._cached_r = inverse_cartan * ones(inverse_cartan.rows, 1)

        r = self._cached_r

        # TODO: Add basis features throughout class
        if basis == 'orthogonal':
            root = root * self.omega_matrix().pinv()

        return (root * r)[0]

    def positive_roots(self):
        """Returns the set of all positive roots that are greater
        than zero in weight from the rootsystem.
        """
        if hasattr(self, "_positive_roots"):
            return self._positive_roots
        n_pos = self.roots() // 2
        self._positive_roots = self.rootsystem()[:n_pos]
        return self._positive_roots

    def orbit(self, weight, stabilizer=None,basis="orthogonal", **kwargs):
        """
        Returns the orbit of the weight or root by reflecting it
        a plane. A stabilizer may be passed to calculate the orbit using
        the Orbit-Stabilizer theorem.

        Note the stabilizer starts counting simple roots at index 0

        Args:
            weight (Matrix): A Matrix of shape (1, rank)
            stabilizer (Iterable of ints, optional): Per Orbit-Stabilizer
            theorem, integer iterable of simple root indexes. Defaults to None.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit
        - https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers

        """
        return orbit(self, weight, stabilizer=stabilizer, **kwargs)

    def _reflection_matrices(self, weight=None):
        """Returns reflection matricies depending on how
        weight is (or isn't) passed.

        - If weight is None, then
        a set of reflection matrices generated from simple roots are
        returned.
        - If weight is type of Matrix then a single matrix
        is returned by rotating the weight.
        - If weight is type of list (implied of MatrixBase) then
        rotations are done on each MatrixBase and returned.
        """
        reflection_matrix = lambda v: (eye(len(v)) - 2 * v.T * v / v.dot(v)).as_immutable()

        # simple_roots generated reflection matrices
        if weight is None:
            return [reflection_matrix(x) for x in self.simple_roots()]

        if isinstance(weight, MatrixBase):
            return reflection_matrix(weight)

        if isinstance(weight,list):
            return [reflection_matrix(x) for x in weight]

    def quadratic_form(self):
        r"""Returns the metric tensor of the algebra. Because of
        usefulness in calculations, it is returned in the omega basis.

        Metric tensor in orthogonal basis is

        .. math::
            D_{ii} = \langle \alpha_i, \alpha_i \rangle / 2


        while returning it in the omega basis is

        .. math::
            D' = A^{-1} D


        where $A$ is the cartan matrix.

        """

        if hasattr(self, "_quadratic_form"):
            return self._quadratic_form
        quadratic_form = zeros(self.rank)
        sr = self.simple_roots()
        for i in range(self.rank):
            quadratic_form[i,i] = sr[i].dot(sr[i]) / 2
        self._quadratic_form = self.cartan_matrix().pinv() * quadratic_form
        return self._quadratic_form

    @list2matrix
    def basis_transform(self, weight, basis_in, basis_out):
        """Transforms a weight from basis_in to basis_out.
        Basis must be in {"orthogonal", "omega", "alpha"}.
        """

        if basis_out == "orthogonal":
            return self.to_orthogonal(weight, basis_in)
        if basis_out == "omega":
            return self.to_omega(weight, basis_in)
        if basis_out == "alpha":
            return self.to_alpha(weight, basis_in)
        raise KeyError("Lie basis not found")

    @list2matrix
    def to_orthogonal(self, weight, basis):
        """Returns the weight in the orthogonal basis from the current
        basis. The orthogonal basis is the basis where simple roots are
        written in a Euclidean subspace.
        """
        is_row = weight.shape[0] == 1

        if not is_row:
            return self.to_orthogonal(weight.T, basis).T

        if basis == "orthogonal":
            return weight
        if basis == "alpha":
            return weight * self.cartan_matrix() * self.omega_matrix()
        if basis == "omega":
            return weight * self.omega_matrix()
        raise KeyError("Lie basis not found")

    @list2matrix
    def to_alpha(self, weight, basis):
        """Returns the weight in the alpha basis from the current
        basis. The alpha basis is the basis of the simple roots.
        """
        is_row = weight.shape[0] == 1

        if not is_row:
            return self.to_alpha(weight.T, basis).T

        if basis == "orthogonal":
            return weight * self.omega_matrix().pinv() * self.cartan_matrix().pinv()
        if basis == "alpha":
            return weight
        if basis == "omega":
            return weight * self.cartan_matrix().pinv()
        raise KeyError("Lie basis not found")

    @list2matrix
    def to_omega(self, weight, basis):
        """Returns the weight in the omega basis from the current
        basis. The omega basis is the basis where all simple roots
        are written as rows of the cartan matrix. Also called the
        Dynkin Basis. This is the basis of the fundamental weights."""

        is_row = weight.shape[0] == 1

        if not is_row:
            return self.to_omega(weight.T, basis).T

        if basis == "orthogonal":
            return weight * self.omega_matrix().pinv()
        if basis == "alpha":
            return weight * self.cartan_matrix()
        if basis == "omega":
            return weight
        raise KeyError("Lie basis not found")

    @list2matrix
    def single_dominant_weights(self, irrep, basis="omega"):
        r"""Returns the single dominant weights of the irreducible representation.
        This is done by recursively subtracting positive roots until no new dominant root is
        found. A dominant root is defined to be

        .. math::

            dom(w) = \{ w_i \in w | w_i \geq 0 \}

        """
        def select_pos(irrep):
            pos = set()
            for pr in pr_omega:
                res = irrep - pr
                if all(x >=0 for x in res):
                    pos.add(tuple(res))
            return pos

        def union_new_weights(irreps):
            res = set()
            for w in irreps:
                res = res.union(select_pos(w))
            return res

        irrep = self.to_omega(irrep, basis)
        pr_omega = [self.to_omega(x,"orthogonal") for x in self.positive_roots()]

        tower = [irrep]
        tower_set = set([tuple(irrep)])
        while True:
            temp = union_new_weights(tower)
            diff = temp.difference(tower_set)

            if len(diff) == 0:
                break

            for x in diff:
                tower.append(Matrix([[*x]]))
                tower_set.add(x)

        return sorted(tower, key=self.k_level)[::-1]

    @list2matrix
    def weight_multiplicity(self, weight, irrep, basis="omega"):
        """Returns the weight multiplicity in the irreducible representation"""
        irrep = self.to_omega(irrep, basis)
        dominant_weight, _ = self.chamber_rotate(weight, basis)
        dominant_irrep = self.single_dominant_weights(irrep)

        if irrep == dominant_weight:
            return 1
        # omega basis from here on
        k = int(self.k_level(irrep-weight, basis))

        # group the xi, weight(if it is dominant) and its multiplicity
        # by adding xi to it over and over. This is analagous to
        # the ladder operator in quantum mechanics (actually this is where qm gets it from)
        highest_weights = []
        for i in range(k):
            for xi, mul in self.xi_multiplicity(dominant_weight):
                dom = dominant_weight + (i+1) * xi
                if dom in dominant_irrep:
                    highest_weights.append((dom, xi, mul))

        # Below is freudenthal's recursion formula
        multiplicity = 0
        rho = ones(1, self.rank)
        for (w, xi, m) in highest_weights:
            dom, _ = self.chamber_rotate(w)

            # breaking up fraction into pieces for easier (hopefully) reading
            num = m * self.weight_multiplicity(dom, irrep) * self.scalar_product(w, xi)
            d1 = self.scalar_product(irrep + rho, irrep + rho)
            d2 = self.scalar_product(dominant_weight + rho, dominant_weight + rho)
            multiplicity += num / (d1-d2)
        return multiplicity

    @list2matrix
    def scalar_product(self, weight1, weight2, basis="omega"):
        """Returns the scalar product between to weights. If the incoming
        basis is orthogonal, it is a simple inner product. Otherwise
        it is done by taking the product by inserting
        a rotation by the quadratic form due to the lack of orthogonality."""
        if basis == "orthogonal":
            return weight1.dot(weight2)
        weight1 = self.to_omega(weight1, basis)
        weight2 = self.to_omega(weight2, basis)
        return (weight1 * self.quadratic_form()).dot(weight2)

    @list2matrix
    def k_level(self, weight, basis="omega"):
        """Returns the level of the weight or irrep. This is the sum
        of the weight or irrep in the alpha basis"""
        return sum(self.to_alpha(weight, basis))

    def chamber_rotate(self, weight, basis="omega"):
        """Returns the tuple of (dominant weight, parity) of weight the
        into the dominant chamber using weyl reflections across the weyl chambers.
        """
        return _chamber_rotate(self,weight, basis)


    @list2matrix
    def xi_multiplicity(self, weight, basis="omega"):
        """Returns a list of tuples that are the multiplicty and xi of
        each the weight.

        Xi is defined to be a member of the
        positive roots where each coeffcient is positive
        nonzero. The multiplicity is the dimension of that
        xi's orbit.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> a4 = CartanType("A4")
        >>> a4.xi_multiplicity([0,1,0,0])
        [(Matrix([[1, 0, 0, 1]]), 12),
        (Matrix([[0, -1, 1, 1]]), 6),
        (Matrix([[2, -1, 0, 0]]), 2)]
        """
        weight = self.to_omega(weight, basis)

        # performance considerations
        if not hasattr(self, "_weight_multiplicity_cache"):
            self._weight_multiplicity_cache = {}

        cached_selection = self._weight_multiplicity_cache.get(tuple(weight))
        if cached_selection:
            return cached_selection

        xi_multiplicity = []
        stabs = set()

        # Find the stabilizers. np.argwhere(weight == 0)
        for idx, i in enumerate(weight):
            if i == 0:
                stabs.add(idx)

        # Unique representativeness of the orbit
        # xis are the positive roots where weight has nonzero
        # coeffecients.
        xis = []
        prs = [self.to_omega(x, "orthogonal") for x in self.positive_roots()]
        for pr in prs:
            if all(pr[i] >= 0 for i in stabs):
                xis.append(pr)

        for xi in xis:
            xi_stab = set()
            temp = self.to_alpha(xi, "omega")
            for i in range(self.rank):
                if temp[i] > 0:
                    xi_stab.add(i)
            diff = xi_stab.difference(stabs)

            orbit = self.orbit(self.to_orthogonal(xi, "omega"), stabilizer=stabs)
            # length or orbit differs due to that if the stab is in the xis, then
            # the negative roots are included, thus we multiply the opposite case by 2
            if len(diff) == 0:
                xi_multiplicity.append((xi, len(orbit)))
            else:
                xi_multiplicity.append((xi, 2 * len(orbit)))

        # cache for use later, worth it in large ranked classes.
        self._weight_multiplicity_cache[tuple(weight)] = xi_multiplicity
        return xi_multiplicity


    @list2matrix
    def weight_system(self, irrep, basis="omega"):
        """Returns the entire weight system using the irreducible representation
        as the highest weight and subtracting down to the lowest weight of the
        representation. This can be done by generating the single dominant weights
        from the irrep and calculating their respective multiplicities. Then for joining
        all the weyl orbits (up to their multiplicity factor) for each dominant weight.
        The final result is sorted by k_level.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> a2 = CartanType("A2")
        >>> a2.weight_system([1, 1]) # aka the adjoint
        [Matrix([[1, 1]]),
         Matrix([[-1, 2]]),
         Matrix([[2, -1]]),
         Matrix([[0, 0]]),
         Matrix([[0, 0]]),
         Matrix([[-2, 1]]),
         Matrix([[1, -2]]),
         Matrix([[-1, -1]])]
        """
        irrep = self.to_omega(irrep, basis)
        dom_weight_system = [
            (x, self.weight_multiplicity(x, irrep)) for x in self.single_dominant_weights(irrep)]

        weight_system = []
        for weight, m in dom_weight_system:
            weight_system += [self.orbit(weight, basis="omega")] * m
        weight_system = flatten(weight_system, levels=1)
        return sorted(weight_system, key=lambda s: self.k_level(irrep - s))

    @list2matrix
    def dim(self, weight, basis="omega"):
        r"""Returns the dimension of the weight, root or irreducible representations.
        This follows Weyl's dimension formula:

        .. math::
            dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}

        where $\Delta^{+}$ are the positive roots and $rho$ is the sum of
        the positive roots: `[1] * rank`.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> a2 = CartanType("A2") # aka SU(3)
        >>> a2.dim([1,0]) # fundamental rep
        3
        """

        # weight must be in omega basis while posroots are in alpha
        # as defined by the weyl formula
        weight = self.to_omega(weight, basis)
        rho = ones(1, self.rank)
        pr_omega = [self.to_omega(x,"orthogonal") for x in self.positive_roots()]

        dim = 1
        for root in pr_omega:
            numer = self.scalar_product(weight + rho, root)
            denom = self.scalar_product(rho, root)
            dim *= (numer / denom)
        return _sympify(dim)

    def tensor_product_decompose(self, *weights, basis="omega"):
        """Returns the tensor product between irreducible representations
        as a the tensor sum of the irreducible representations of their
        highest weights. This algorithm is based on Klimky's formula.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> a2 = CartanType("A2")
        >>> res = a2.tensor_product_decompose([1,0], [0,1])
        >>> res
        [Matrix([[0, 0]]), Matrix([[1, 1]])]
        >>> [a2.dim(x) for x in res]
        [1, 8]


        Sources
        =======
        - https://mathoverflow.net/questions/85593/decompose-tensor-product-of-type-g-2-lie-algebras
        """
        if len(weights) < 2:
            raise ValueError("Tensor product must have >2 weights")

        decomp = []
        N = len(weights)
        for i in range(N-1):
            decomp += _tensor_product_decomp(self, weights[i], weights[i+1], basis)
        return decomp

@list2matrix
def _chamber_rotate(algebra: Standard_Cartan, weight, basis):
    parity = 1

    # is incoming weight already dominant?
    weight_omega = algebra.to_omega(weight, basis)
    if all(x >=0 for x in weight_omega):
        return weight, parity

    if weight.shape[0] != 1:
        weight = weight.T

    reflected = [algebra.to_orthogonal(weight, basis)]

    reflection_matricies = algebra._reflection_matrices()

    # keep reflecting until dominant is found
    while True:
        temp = []
        for m in reflection_matricies:
            for r in reflected:
                r *= m
                parity *= -1
                reflected_omega = algebra.to_omega(r, "orthogonal")
                if all(x >=0 for x in reflected_omega):
                    return reflected_omega, parity
                temp.append(r)
        reflected += temp


@list2matrix
def _tensor_product_decomp(algebra, weight1, weight2, basis="omega"):

    # implementation of c++ std::adjacent_find
    # generator for comparing two adjacent items
    # in an interable based on some predicate `func`
    def adjacent_find(it, func):
        for idx, i in enumerate(it):
            if idx + 1 >= len(it):
                return
            if func(i) == func(it[idx+1]):
                yield idx

    weight1 = algebra.to_omega(weight1, basis)
    weight2 = algebra.to_omega(weight2, basis)

    tower1 = algebra.weight_system(weight1)
    rho = ones(1, algebra.rank)

    # calculating the parity upon weyl rotation across chambers
    # and ignoring the weights on the wall
    weight_parities = []
    i = 0
    for w in tower1:
        t, parity = algebra.chamber_rotate(w + weight2 + rho)
        print(i)
        # drop weights lying on the weyl domain wall
        if not any([x==0 for x in t]):
            t -= rho
            weight_parities.append([parity, t])
        i+=1
    # sort by weight in omega basis
    weight_parities = sorted(weight_parities, key=lambda x: tuple(x[1]))

    # groupby and sum on multiplicity
    for i in adjacent_find(weight_parities, lambda x: x[1]):
        weight_parities[i+1][0] += weight_parities[i][0]
        weight_parities[i][0] = 0

    # expand each product result by its multiplicity
    tensor_product_decomp = []
    for m, w in weight_parities:
        tensor_product_decomp += [w]*m

    return tensor_product_decomp
